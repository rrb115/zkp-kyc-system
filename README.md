# zkP-KYC System — State of Residence Verifier

A compact demonstration project that shows how to verify a user's "state of residence" using zero-knowledge proofs (Circom + snarkjs, Groth16) together with Solidity contracts (Hardhat). This README is written for a general audience — developers, auditors, or contributors who want to run, test, or extend the project.

Summary
- Purpose: Prove on-chain that a user satisfies a "state of residence" predicate without revealing sensitive data.
- Components:
  - circuits/: Circom circuits and build artifacts for generating ZK proofs.
  - contracts/: Solidity verifier and coordinator (requesting/fulfillment) contracts.
  - scripts/: Hardhat scripts for deployment and interactions.
  - test/: Unit and integration tests (Hardhat).

Prerequisites
- Node.js (16+ recommended) and npm or yarn.
- npx (comes with npm).
- Optional but common: circom (v2) and snarkjs for local circuit compilation and proof generation. These can be installed globally or used via devDependencies.
- Hardhat (installed as a project dependency) for compiling, testing, and deploying contracts.

Quick start (local)
1. Install dependencies:
   npm install
   or
   yarn

2. (Optional) Install Circom and snarkjs globally for convenience:
   npm install -g circom snarkjs

3. Compile contracts:
   npx hardhat compile

4. Run local tests:
   npx hardhat test

5. Run a local node (for manual interaction):
   npx hardhat node

6. Deploy to local network (example):
   npx hardhat run --network localhost scripts/deploy.js

Circuits workflow (high-level)
- Compile a circuit:
  circom circuits/YourCircuit.circom --r1cs --wasm --sym -o circuits/build

- Trusted setup (dev quick flow):
  snarkjs powersoftau new bn128 12 pot12_0000.ptau
  snarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name="contrib"
  snarkjs groth16 setup circuits/build/YourCircuit.r1cs pot12_0001.ptau circuits/build/YourCircuit_0000.zkey
  snarkjs zkey contribute circuits/build/YourCircuit_0000.zkey circuits/build/YourCircuit_final.zkey
  snarkjs zkey export verificationkey circuits/build/YourCircuit_final.zkey circuits/build/verification_key.json

- Witness, prove, verify:
  node circuits/build/YourCircuit_js/generate_witness.js circuits/build/YourCircuit_js/YourCircuit.wasm input.json circuits/build/witness.wtns
  snarkjs groth16 prove circuits/build/YourCircuit_final.zkey circuits/build/witness.wtns circuits/build/proof.json circuits/build/public.json
  snarkjs groth16 verify circuits/build/verification_key.json circuits/build/public.json circuits/build/proof.json

- Export on-chain verifier:
  snarkjs zkey export solidityverifier circuits/build/YourCircuit_final.zkey contracts/YourCircuitVerifier.sol

Important notes about circuits and public signals
- Keep publicSignals ordering consistent between the circuit and the on-chain verifier/coordination contract. Mismatched ordering is the most common cause of on-chain verification failures.
- Use unique nullifiers to prevent replay of the same proof; the contract tracks used nullifiers.
- Do not include secrets or private keys in proof artifacts stored in repositories.

Contracts overview
- StateOfResidenceVerifier.sol
  - Manages verification requests and stores state (requester, user, required state, timestamps, fees).
  - Contacts an Attester-like contract to confirm the user has a valid attestation/commitment.
  - Calls the on-chain Groth16 verifier contract to verify received proofs and public signals.
  - Protects against reuse (nullifiers), refunds, and simple reward logic.

- StateOfResidenceGroth16Verifier (generated by snarkjs)
  - Standard Groth16 Solidity verifier used by the coordinator contract.

Common Hardhat commands
- Compile: npx hardhat compile
- Test: npx hardhat test
- Run script: npx hardhat run scripts/<script>.js --network <network>
- Local node: npx hardhat node
- Deploy to a target network: npx hardhat run --network <network> scripts/deploy.js

Security and deployment considerations
- For production use, do not use the simple dev trusted-setup flow. Use a proper multiparty ceremony (powers-of-tau + multiple zkey contributions) and keep zkey provenance.
- Do not publish private keys or unencrypted RPC credentials. Use environment variables or secret managers for deployments.
- Verify on-chain verifier code matches the zkey used to generate proofs.
- Gas: Verifying Groth16 proofs on-chain is expensive; evaluate gas costs for your target chain.

Repository layout (brief)
- circuits/   : Source circuits (.circom), inputs, and build output (wasm, r1cs, zkey, proof artifacts).
- contracts/  : Solidity contracts (verifier and coordinator).
- scripts/    : Scripts for deployment and helper actions.
- test/       : Tests for contracts and flows.
- artifacts/  : Hardhat build artifacts (populated after compile).

Troubleshooting (common issues)
- "Invalid ZK proof" on-chain: Confirm verifier matches the zkey that generated proofs and public signal order is correct.
- "Proof has already been used": The public nullifier value was already registered as used; ensure unique nullifiers.
- circom/snarkjs errors: Check local versions; prefer circom v2 and a compatible snarkjs version.

Resources
- Circom docs: https://docs.circom.io/
- snarkjs: https://github.com/iden3/snarkjs
- Hardhat: https://hardhat.org/
- Ethers.js: https://docs.ethers.io/

If you want a tailored step-by-step example (full circuit, inputs, witness generation, proof, contract deploy, and a sample transaction that completes a verification end-to-end), indicate whether you prefer a local-only walkthrough or one that targets a public testnet and which proof parameters you want to use.
2. The contract checks the Attester contract to ensure the user has a valid card and stores the request.
3. User generates a ZK proof off-chain that proves:
   - their state commitment matches a committed state
   - the required state matches the requested value
   - the proof includes a nullifier to prevent reuse
   - the requestId and requester are included in public signals so on-chain checks can verify link
4. User calls completeStateVerification(requestId, proof, publicSignals). The contract:
   - verifies public signals match the stored request and commitments retrieved from the Attester
   - calls the Groth16 verifier contract to validate the proof
   - marks request completed and rewards user a portion of the fee

Key developer tips
- Keep public signal ordering consistent between Circom circuit and the Solidity contract checks.
- Use deterministic input.json when testing to reproduce proofs.
- If you recompile/alter circuits, re-run the trusted setup (zkey) and re-export the solidity verifier to keep verifier code and keys in sync.
- Don't expose private keys or sensitive data in public.json or proof artifacts.

Folder overview
- circuits/   : Circom circuits (.circom), test inputs, and build output (wasm, r1cs, zkey artifacts)
- contracts/  : Solidity contracts (verifier + coordination contract)
- scripts/    : Hardhat scripts to deploy and interact with contracts
- test/       : Hardhat tests (unit/integration)
- artifacts/  : Hardhat build artifacts after compilation

Troubleshooting
- "Invalid ZK proof" on-chain: verify you used the correct zkey/verification key and that publicSignals order matches contract checks.
- "Proof has already been used": nullifier public signal was already marked used — ensure unique nullifiers per proof.
- Circom or snarkjs errors: check versions. Use circom v2 + matching snarkjs versions where Groth16 toolchain is supported.

Further reading and links
- Circom docs: https://docs.circom.io/
- snarkjs: https://github.com/iden3/snarkjs
- Hardhat: https://hardhat.org/
- Ethers.js (used by Hardhat scripts): https://docs.ethers.io/

If you need a hands-on example for a specific circuit or a tailored deploy/test script, indicate which part you want automated and the expected network (local / testnet).
