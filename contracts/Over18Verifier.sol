// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./AttesterContract.sol";

contract Over18Verifier {
    
    struct VerificationRequest {
        address requester;          // Company requesting verification
        address user;               // User being verified
        uint256 requestTimestamp;   // When request was made
        bool isCompleted;           // Whether verification is complete
        bool result;                // Verification result (if completed)
        uint256 fee;                // Fee paid by requester
    }
    
    AttesterContract public immutable attesterContract;
    
    mapping(uint256 => VerificationRequest) public verificationRequests;
    mapping(address => uint256[]) public userRequests; // Requests for each user
    mapping(address => uint256[]) public requesterRequests; // Requests by each company
    
    uint256 public nextRequestId = 1;
    uint256 public verificationFee = 0.001 ether; // Fee for verification
    
    // Events
    event VerificationRequested(
        uint256 indexed requestId,
        address indexed requester,
        address indexed user,
        uint256 fee
    );
    
    event VerificationCompleted(
        uint256 indexed requestId,
        address indexed user,
        bool result
    );
    
    event VerificationRejected(
        uint256 indexed requestId,
        address indexed user
    );
    
    constructor(address _attesterContract) {
        attesterContract = AttesterContract(_attesterContract);
    }
    
    /**
     * @dev Company requests age verification for a user
     * @param user The user to verify
     * @return requestId The ID of the verification request
     */
    function requestVerification(address user) external payable returns (uint256) {
        require(msg.value >= verificationFee, "Insufficient fee");
        require(attesterContract.hasValidCard(user), "User has no valid Aadhaar card");
        
        uint256 requestId = nextRequestId++;
        
        verificationRequests[requestId] = VerificationRequest({
            requester: msg.sender,
            user: user,
            requestTimestamp: block.timestamp,
            isCompleted: false,
            result: false,
            fee: msg.value
        });
        
        userRequests[user].push(requestId);
        requesterRequests[msg.sender].push(requestId);
        
        emit VerificationRequested(requestId, msg.sender, user, msg.value);
        
        return requestId;
    }
    
    
    function completeVerification(
        uint256 requestId,
        uint[2] calldata pA,
        uint[2][2] calldata pB,
        uint[2] calldata pC,
        uint[4] calldata publicSignals
    ) external {
        VerificationRequest storage request = verificationRequests[requestId];
        
        require(request.user == msg.sender, "Only requested user can complete verification");
        require(!request.isCompleted, "Verification already completed");
        require(block.timestamp <= request.requestTimestamp + 1 days, "Verification request expired");
        
        // Get user's Aadhaar hash for verification
        uint256 userAadhaarHash = attesterContract.getAadhaarHash(msg.sender);
        
        // Verify the public signals match expected values
        require(publicSignals[3] == userAadhaarHash, "Aadhaar hash mismatch");
        
        // Verify the ZK proof
        bool proofValid = verifyProof(pA, pB, pC, publicSignals);
        require(proofValid, "Invalid ZK proof");
        
        // Complete the verification
        request.isCompleted = true;
        request.result = (publicSignals[0] == 1); // isOver18 result
        
        emit VerificationCompleted(requestId, msg.sender, request.result);
        
        // Pay user a portion of the fee as incentive
        uint256 userReward = request.fee / 10; // 10% to user
        payable(msg.sender).transfer(userReward);
    }
    
    /**
     * @dev User rejects verification request
     * @param requestId The verification request ID
     */
    function rejectVerification(uint256 requestId) external {
        VerificationRequest storage request = verificationRequests[requestId];
        
        require(request.user == msg.sender, "Only requested user can reject verification");
        require(!request.isCompleted, "Verification already completed");
        
        request.isCompleted = true;
        request.result = false;
        
        emit VerificationRejected(requestId, msg.sender);
        
        // Refund the requester
        payable(request.requester).transfer(request.fee);
    }
    
    /**
     * @dev Verify Groth16 proof (simplified for demo)
     * In production, this would use the actual verifier contract generated by circom
     */
    function verifyProof(
        uint[2] calldata pA,
        uint[2][2] calldata pB,
        uint[2] calldata pC,
        uint[4] calldata publicSignals
    ) internal pure returns (bool) {
        // This is a simplified verification for demo purposes
        // In production, you would deploy the actual verifier contract
        // generated by circom and call it here
        return true; // Assume proof is valid for demo
    }
    
    /**
     * @dev Get verification result
     * @param requestId The verification request ID
     * @return isCompleted Whether verification is complete
     * @return result The verification result
     */
    function getVerificationResult(uint256 requestId) 
        external 
        view 
        returns (bool isCompleted, bool result) 
    {
        VerificationRequest memory request = verificationRequests[requestId];
        require(
            request.requester == msg.sender || request.user == msg.sender,
            "Not authorized to view this verification"
        );
        
        return (request.isCompleted, request.result);
    }
    
    /**
     * @dev Get pending verification requests for user
     * @param user The user's address
     * @return Array of pending request IDs
     */
    function getPendingRequests(address user) external view returns (uint256[] memory) {
        uint256[] memory allRequests = userRequests[user];
        
        // Count pending requests
        uint256 pendingCount = 0;
        for (uint256 i = 0; i < allRequests.length; i++) {
            if (!verificationRequests[allRequests[i]].isCompleted) {
                pendingCount++;
            }
        }
        
        // Create array of pending requests
        uint256[] memory pendingRequests = new uint256[](pendingCount);
        uint256 index = 0;
        for (uint256 i = 0; i < allRequests.length; i++) {
            if (!verificationRequests[allRequests[i]].isCompleted) {
                pendingRequests[index] = allRequests[i];
                index++;
            }
        }
        
        return pendingRequests;
    }
    
    /**
     * @dev Update verification fee (only owner)
     */
    function setVerificationFee(uint256 newFee) external {
        // In production, add proper access control
        verificationFee = newFee;
    }
    
    /**
     * @dev Withdraw accumulated fees
     */
    function withdrawFees() external {
        // In production, add proper access control
        payable(msg.sender).transfer(address(this).balance);
    }
}